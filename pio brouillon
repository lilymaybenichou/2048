# brouillon projet
from tkinter import Frame,Label,CENTER
import random as R
import random 
import copy 


print("\033[0;97m 2")
print("\033[0;96m 4")
print("\033[0;95m 8")
print("\033[0;94m 16")
print("\033[0;93m 32")
print("\033[0;92m 64")
print("\033[0;91m 128")
print("\033[0;90m 256")
print("\033[0;37m 512")
print("\033[0;36m 1024")
print("\033[0;35m 2048")
print("\033[0;34m 4096")
print("\033[0;33m 8192")
print("\033[0;32m 16384")
print("\033[0;31m 32768")
print("\033[0;30m 65536")

# fonction pour commencer le jeu
def start_game():
    mat=[]
    for i in range(4):
        mat.append([0]*4)
    return mat

# fonction pour ajouter une nouvelle case
def add_new_2(mat):
    r=R.randint(0,3)
    c=R.randint(0,3)

    while(mat[r][c]!=0):
        r=R.randint(0,3)
        c=R.randint(0,3)

    mat[r][c]=2 

#fonction pour 
def get_current_state(mat):
    #si le 2048 et present alors la partie n est pas encore termine
    for i in range(4):
        for j in range(4):
            if mat[i][j]==2048:
                return 'WIN'
    #si 0 est present dans le jeu la partie n'est pas fini
    for i in range(4):
        for j in range(4):
            if mat[i][j]==0:
                return 'GAME NOT OVER '
    #  à l’exception de la dernière ligne ou colonne, il existe des valeurs égales adjacentes à
    for i in range(3):
        for j in range(3):
            if mat[i][j]==mat[i+j][j] or mat[i][j]==mat[i][j+1]:
                return 'GAME NOT OVER'
    ## pour les derniere ligne
    for j in range(3):
        if mat[4][j]==mat[4][j+1]:
            return ' GAME NOT OVER'
        
    for i in range(3):
        if mat[i][4]==mat[i+j][4]:
            return "GAME NOT OVER"
    return ' LOST'

def compress(mat):
    new_mat=[]
    changed=False
    for i in range(4):
        new_mat.append([0]*4)
    
    for i in range(4):
        pos=0
        for j in range(4):
            ##print(i,j,pos)
            if mat[i][j]!=0:
                new_mat[i][pos]=mat[i][j]
                if j!=pos:
                    changed=True
                pos=pos+1

    return new_mat,changed

def merge(mat):
    changed=False
    for i in range(4):
        for j in range(3):
            if mat[i][j]==mat[i][j+1]:
                mat[i][j]=mat[i][j]*2 
                mat[i][j+1]=0
                changed=True 
    return mat,changed

def reversed(mat):
    new_mat=[]
    for i in range(4):
        new_mat.append([])
        for j in range(4):
            new_mat[i].append(mat[i][4-j-i])
    return new_mat

def transpose(mat):
    new_mat=[]
    for i in range(4):
        new_mat.append([])
        for j in range(4):
            new_mat[i].append(mat[j][i])
    return new_mat 

def move_left(mat):
    new_mat,change1=compress(mat)
    new_mat,change2=merge(new_mat)
    changed=change1 and change2
    new_mat,temp=compress(new_mat)

    return new_mat,changed

def move_right(mat):
    new_mat=reversed(mat)
    new_mat,change1=compress(mat)
    new_mat,change2=merge(new_mat)
    changed=change1 or change2
    new_mat,temp=compress(new_mat)
    new_mat=reversed(new_mat)

    return new_mat,changed

def move_up(mat):
    new_mat=transpose(mat)
    new_mat,change1=compress(new_mat)
    new_mat,change2=merge(new_mat)
    changed=change1 or change2
    new_mat,temp=compress(new_mat)
    new_mat=transpose(new_mat)
    return new_mat,changed

def move_down(mat):
    new_mat=transpose(mat)
    new_mat=reversed(new_mat)
    new_mat,change1=compress(new_mat)
    new_mat,change2=merge(new_mat)
    changed=change1 or change2
    new_mat,temp=compress(new_mat)
    new_mat=reversed(new_mat)
    new_mat=transpose(new_mat)
    return new_mat,changed 

SIZE=400
GRID_LEN=4
GRID_PADDING=10

BACKGROUND_COLOR_GAME="#92877d"
BACKGROUND_COLOR_CELL_EMPTY='#9e848a'

BACKROUND_COLOR_DICT={ 2:"#eee4da",4:"#ede0c8",8:"#f2b179",
                      16:"#f59563",32:"#f67c5f",64:"#f65e3b",
                      128:"#edcf72",256:"#edcc61",512:"#edc850",
                      1024:"#f9f6f2",2048:"#f9f6f2",4096:"#f9f6f2",
                      8192:"#f9f6f2",16384:"#f9f6f2",32768:"#f59563",
                      65536:"#f67c5f"
                      }
CELL_COLOR_DICT={ 2:"776e65", 4:"#776e65",8:"#f9f6f2",
                 16:"#f9f6f2",32:"#f9f6f2",64:"#f9f6f2",
                 128:"#f9f6f2",256:"#f9f6f2",512:"#f9f6f2",
                 1024:"#f9f6f2",2048:"#f9f6f2",4096:"#f9f6f2",
                 8192:"#f9f6f2",16384:"#f9f6f2",32768:"#f9f6f2",
                 65536:"#f9f6f2"}
FONT=("verdana",40,"bold")

KEY_UP="'w'"
KEY_DOWN="'s'"
KEY_LEFT="'a'"
KEY_RIGHT="'d'"
        

# Ici creation du jeu 2048 avec different etapes pour le 17 avril 2023
# On vas le faire ici en different etable etapes
# a= etape intro vu precedement
#b=Creation de touche pour avancer + transposer les cases notamment avec les fonctions reverse pour inverser comme vu precemment
# c=Creation du debut du jeu c est a dire par exemple afficher deux valeur aleatoire 75% d avoir deux 2 et 25 % d avoir un 4
# d= tour du jeu 
# e=Additon de valeur
# f=Fonction gagner ou perdre 


#a
# neanmoins pour ne pas gener la mobilite du tableau autant utiliser 
# creation d un tableau 
 # car 16 colonnes dans notre tableau 
# Definiton de la taille du tableau 
tailledutableau=4
# permettant de modeler le tableau a notre facon 
def display():# display a peut pres egale a la fonction print mais en mieux pour mieux afficher les chiffres par exemples
# fonction conduisant le tableau seulement dans la console et pas dans la fenetre pour le moment
     largest = tableau[0][0]
     for row in tableau:
        for element in row:
            if element > largest:  # complmentariter des elemnt en fonction de la largeur de notre tableau
                largest = element

    # mettre le maximum d espace pour le besoin pour les gros chiffre notament
     numSpaces = len(str(largest))


     for row in tableau:
        currRow = "|" # la fonction currRow permet de mettre des barriers
        for element in row:
            #Si l elemnt est = 0 il y a de la place 
            if element == 0:
                currRow += "" * numSpaces + "|"
                #SI non nous avons la valeur 
            else:
              currRow += (""* (numSpaces - len(str(element)))) + str(element) + "|" # pour avoir plus de place pour les plus de place grand element

        # Afficher la ligne generatrice 
        print(currRow)
     print()
    
    
#display()
 # a savoir si on multiplie un string avec un nombre cela cree un nouveau string 
 # si on multiplie un espace par 4 le nouveau string sera de 4 espace 
 # pour un grand nombre on as besoin par exemple pour ces 1 chiffres de 2 espace 
 # pour cela on vas modifier le code a cett endroit currrow str


#b 
# creation d une fonction pour faire bouger une ligne a gauche par exemple 
def transposeuneseulligne(row):
    # permetrre a tout les elements de bouger si possible vers la gauche but rechercher 
    for j in range (tailledutableau - 1):
      for i in range (tailledutableau -1,0,-1):
        # ici permettre au case vide d etre remplie du faite que elle se feront bouger vers les case libres
        if row[i-1] ==0 : # 
           row[i - 1] = row[i]
           row[i] = 0

    # permettre a toute les valeur de fusionner vers la gauche 
    for i in range(tailledutableau - 1):
        # test pour savoir si les deux valeurs sont identtique et pour le prochain 
        if row[i] == row[i+1]:
          row[i]*=2
          row[i + 1] = 0 

    # tous faire mettre vers la gauche encore une fois 
    for i in range(tailledutableau -1,0,-1):
        if row[i - 1]==0 :
           row[i - 1] = row[i]
           row[i]=0
    return row 

# cette fonction fusionne tous le tableau a gauche 
def transposegauche(actuelletableau):
    # fusionne tout les lignes a gauche du tableau 
    for i in range(tailledutableau):
        actuelletableau[i] = transposeuneseulligne(actuelletableau[i])

    return actuelletableau
    
# fonction pour les differentes direction 
def reverse(row):
    # tous les element dans la ligne son dans une liste et leur role sera inverser 
    new=[]
    for i in range(tailledutableau -1,-1,-1):
        new.append(row[i])
    return new 

# fonction pour fusionner tout les element a droite 
def transposedroite(actuelletableau):
    #pour toute les ligne du tableau 
   for i in range(tailledutableau):
       # Renverse lles lignes transpose a gauche  et les reverse en arriere
       actuelletableau[i]= reverse(actuelletableau[i])
       actuelletableau[i]= transposeuneseulligne(actuelletableau[i])
       actuelletableau[i]= reverse(actuelletableau[i])
   return actuelletableau


# pour aller en haut
# la fonction transpose permet de retourner le tableau en diagonale
# creation de la fonction transpose permettant la transpose dans tout le tableau 
# par exemple un element de la premiere colonne et de la deuxieme ligne,
#ira dans la seconde ligne de la deuxieme colonne
# creation de la fonction transpose 
# pas actuellement fini
def transpose(actuelletableau):
    for j in range(tailledutableau): # permmenant a des element de voir si il sont dans differente diagonale 
        for i in range(j,tailledutableau):
            if not i == j : # pour les partagers echanger les element de la diagonale
                bones = actuelletableau[j][i] # swap
                actuelletableau[j][i] = actuelletableau[i][j]
                actuelletableau[i][j] = bones
    return actuelletableau

# fonction permettant de transposer tout le tableau 
def transposetoutenhaut(actuelletableau):
    # transpose tout le tableau si il est gauche transpose en arriere 
    actuelletableau = transpose(actuelletableau)
    actuelletableau = transposegauche(actuelletableau)
    actuelletableau = transpose(actuelletableau)

    return actuelletableau

# fonction pour tout mettre en bas
def toutenbas(actuelletableau):
    actuelletableau= transpose(actuelletableau)
    actuelletableau= transposedroite(actuelletableau)
    actuelletableau= transpose(actuelletableau)

    return actuelletableau
                               



# c = choisir sois un 2 ou 4 sachant que il a 75% de chance d obtenir un 2 que un 4
def deux_quatre():
    if random.randint(1,8) == 1:
        return 4
    else:
        return 2

#fonction qui met une valeur dans une case vides
def valuercasesvides():
    rowNombre = random.randint(0,tailledutableau-1)
    Nombrecol = random.randint(0,tailledutableau-1)

# trouver un endroit vides 
    while not tableau[rowNombre][Nombrecol] == 0:
       rowNombre = random.randint(0,tailledutableau-1)
       Nombrecol = random.randint(0,tailledutableau-1)

# trouver la case vide avec la nouvelle valeur 
    tableau[rowNombre][Nombrecol] = deux_quatre()

# creation de fonction fin_du_jeu(si la personne a gagner)
def gagner():
    for row in tableau:
        if 2048 in row:
           return True 
    return False

# savoir si la personne a perdu  fonction game over
def bougepas():
    # creation de 2 copy du tableau 
    tableaucopya= copy.deepcopy(tableau)
    tableaucopyb= copy.deepcopy(tableau)
    # test de reconnaisance pour savoir si on peut bouger 
    tableaucopya = toutenbas(tableaucopya)
    if tableaucopya == tableaucopyb:
        tableaucopya = transposetoutenhaut(tableaucopya)
        if tableaucopya == tableaucopyb:
            tableaucopya = transposegauche(tableaucopya)
            if tableaucopya == tableaucopyb:
                tableaucopya = transposedroite(tableaucopya)
                if tableaucopya == tableaucopyb:
                    return True
    return False
# creation d un tableau vierge 
tableau=[]
for i in range(tailledutableau):
    row=[]
    for j in range(tailledutableau):
        row.append(0)
    tableau.append(row)

# 2 valeur apparaissant n importe ou dans le tableau 
nombreapp = 2
while nombreapp>0:
    rowNombre= random.randint(0, tailledutableau - 1)
    Nombrecol=random.randint(0,  tailledutableau - 1)

    if tableau[rowNombre][Nombrecol] ==0:
       tableau[rowNombre][Nombrecol] = deux_quatre()
       nombreapp -=1

print("Bonjour je suis eder militao ")# utilison print pour les message plutot 
display()

# codage pour la determination du fin du jeu 


gameover= False 

while not gameover:
    direct = input("vous voullez ou bouger?")
    # si il peut enocre boujger
    choisivaleur=True 
    # regardons si les mouvements se realise  copy du tableau 
    Hyutableau= copy.deepcopy(tableau) #gardant en mémoire dans un dictionnaire memo les objets déjà copiés durant la phase de copie actuelle 
                                       # permettant de savoir si le joueur a deja appuyer sur la meme touche
    # cette fois on vas bouger en haut a droite de gauche a droite 
    if direct =="d":
      tableau = transposedroite(tableau)
    elif direct =="z":
        tableau = transposetoutenhaut(tableau)
    elif direct == "q":
        tableau = transposegauche(tableau)
    elif direct == "s":
        tableau = toutenbas(tableau)
    else:
       choisivaleur=False  # cela veut dire que l utilisatuer ne peut choisir que 4 touche si il affiche 
                       # autre chose cela veut dire que cela ne s'écutera pas 

    # demander a l utilisateur de donner donner un autre touche si ca touche selectioner et pas correct
    if not choisivaleur:
        print("veuillez choisir un bon resultat s il vous plait ")
    # si sa touche choisi et correct
    else:
       # test si ca bouge 
       if tableau == Hyutableau:
           # leur dire d utiliser une autre fois la touche deja utiliser par exemple
           print("choisir Autre direction cardeja utiliser")
       else:
           # savoir si on as gagner comme cyril gane 
           if gagner():
               display()
               print("Victory like cYRIL gane")
               gameover=True # car le jeu ce termine apres la victoire
           else:
           # ajouter une nouvelle fonction 
             valuercasesvides()
           
             display()

           # determine pas de deplacemnt
           if bougepas():
               print("game over")









    


