# brouillon projet
from tkinter import Frame,Label,CENTER
import random as R
import random 
import copy 

# Voici differente (fonction),(pour le projet)
# fonction chnagement de couleur du plus fonce au plus clair 
print("\033[0;97m 2")
print("\033[0;96m 4")
print("\033[0;95m 8")
print("\033[0;94m 16")
print("\033[0;93m 32")
print("\033[0;92m 64")
print("\033[0;91m 128")
print("\033[0;90m 256")
print("\033[0;37m 512")
print("\033[0;36m 1024")
print("\033[0;35m 2048")
print("\033[0;34m 4096")
print("\033[0;33m 8192")
print("\033[0;32m 16384")
print("\033[0;31m 32768")
print("\033[0;30m 65536")

# quelque fonction avec mat[i][j] 
# fonction pour commencer le jeu
def start_game():
    mat=[]
    for i in range(4):
        mat.append([0]*4)
    return mat

# fonction pour ajouter une nouvelle case
def add_new_2(mat):
    r=R.randint(0,3)
    c=R.randint(0,3)

    while(mat[r][c]!=0):
        r=R.randint(0,3)
        c=R.randint(0,3)

    mat[r][c]=2 

#fonction pour 
def get_current_state(mat):
    #si le 2048 et present alors la partie n est pas encore termine
    for i in range(4):
        for j in range(4):
            if mat[i][j]==2048:
                return 'WIN'
    #si 0 est present dans le jeu la partie n'est pas fini
    for i in range(4):
        for j in range(4):
            if mat[i][j]==0:
                return 'GAME NOT OVER '
    #  à l’exception de la dernière ligne ou colonne, il existe des valeurs égales adjacentes à
    for i in range(3):
        for j in range(3):
            if mat[i][j]==mat[i+j][j] or mat[i][j]==mat[i][j+1]:
                return 'GAME NOT OVER'
    ## pour les derniere ligne
    for j in range(3):
        if mat[4][j]==mat[4][j+1]:
            return ' GAME NOT OVER'
        
    for i in range(3):
        if mat[i][4]==mat[i+j][4]:
            return "GAME NOT OVER"
    return ' LOST'

def compress(mat):
    new_mat=[]
    changed=False
    for i in range(4):
        new_mat.append([0]*4)
    
    for i in range(4):
        pos=0
        for j in range(4):
            ##print(i,j,pos)
            if mat[i][j]!=0:
                new_mat[i][pos]=mat[i][j]
                if j!=pos:
                    changed=True
                pos=pos+1

    return new_mat,changed

def merge(mat):
    changed=False
    for i in range(4):
        for j in range(3):
            if mat[i][j]==mat[i][j+1]:
                mat[i][j]=mat[i][j]*2 
                mat[i][j+1]=0
                changed=True 
    return mat,changed

def reversed(mat):
    new_mat=[]
    for i in range(4):
        new_mat.append([])
        for j in range(4):
            new_mat[i].append(mat[i][4-j-i])
    return new_mat

def transpose(mat):
    new_mat=[]
    for i in range(4):
        new_mat.append([])
        for j in range(4):
            new_mat[i].append(mat[j][i])
    return new_mat 

def move_left(mat):
    new_mat,change1=compress(mat)
    new_mat,change2=merge(new_mat)
    changed=change1 and change2
    new_mat,temp=compress(new_mat)

    return new_mat,changed

def move_right(mat):
    new_mat=reversed(mat)
    new_mat,change1=compress(mat)
    new_mat,change2=merge(new_mat)
    changed=change1 or change2
    new_mat,temp=compress(new_mat)
    new_mat=reversed(new_mat)

    return new_mat,changed

def move_up(mat):
    new_mat=transpose(mat)
    new_mat,change1=compress(new_mat)
    new_mat,change2=merge(new_mat)
    changed=change1 or change2
    new_mat,temp=compress(new_mat)
    new_mat=transpose(new_mat)
    return new_mat,changed

def move_down(mat):
    new_mat=transpose(mat)
    new_mat=reversed(new_mat)
    new_mat,change1=compress(new_mat)
    new_mat,change2=merge(new_mat)
    changed=change1 or change2
    new_mat,temp=compress(new_mat)
    new_mat=reversed(new_mat)
    new_mat=transpose(new_mat)
    return new_mat,changed 

SIZE=400
GRID_LEN=4
GRID_PADDING=10

BACKGROUND_COLOR_GAME="#92877d"
BACKGROUND_COLOR_CELL_EMPTY='#9e848a'

BACKROUND_COLOR_DICT={ 2:"#eee4da",4:"#ede0c8",8:"#f2b179",
                      16:"#f59563",32:"#f67c5f",64:"#f65e3b",
                      128:"#edcf72",256:"#edcc61",512:"#edc850",
                      1024:"#f9f6f2",2048:"#f9f6f2",4096:"#f9f6f2",
                      8192:"#f9f6f2",16384:"#f9f6f2",32768:"#f59563",
                      65536:"#f67c5f"
                      }
CELL_COLOR_DICT={ 2:"776e65", 4:"#776e65",8:"#f9f6f2",
                 16:"#f9f6f2",32:"#f9f6f2",64:"#f9f6f2",
                 128:"#f9f6f2",256:"#f9f6f2",512:"#f9f6f2",
                 1024:"#f9f6f2",2048:"#f9f6f2",4096:"#f9f6f2",
                 8192:"#f9f6f2",16384:"#f9f6f2",32768:"#f9f6f2",
                 65536:"#f9f6f2"}
FONT=("verdana",40,"bold")

KEY_UP="'w'"
KEY_DOWN="'s'"
KEY_LEFT="'a'"
KEY_RIGHT="'d'"
        

# Ici creation du jeu 2048 avec different etapes pour la semaine du  17 avril 2023
# On vas le faire ici en different etable etapes
# a= etape intro vu precedement
#b=Creation de touche pour avancer + transposer les cases notamment avec les fonctions reverse pour inverser comme vu precemment
# c=Creation du debut du jeu c est a dire par exemple afficher deux valeur aleatoire 75% d avoir deux 2 et 25 % d avoir un 4
# d = essayer de mettre des couleur ( a voir au faite de l anvecement du projet pas obligatoire)
# e=Additon de valeur= transpose voir etape b
# f=Fonction gagner ou perdre 
# bonus : faire la fonction restart (pas besoin de le faire si amine ou lily 
# l a fait)

#a
# neanmoins pour ne pas gener la mobilite du tableau autant utiliser 
# creation d un tableau 
 # car 16 colonnes dans notre tableau 
# Definiton de la taille du tableau 
tailledutableau=4
# permettant de modeler le tableau a notre facon 
def display():# display a peut pres egale a la fonction print mais en mieux pour mieux afficher les chiffres par exemples
# fonction conduisant le tableau seulement dans la console et pas dans la fenetre pour le moment
     largest = tableau[0][0] # permettant de definir que le tableau et vides au debut
     for row in tableau:
        for element in row:
            if element > largest:  # complmentariter des elemnt en fonction de la largeur de notre tableau
                largest = element

    # mettre le maximum d espace pour le besoin pour les gros chiffre notament
     numSpaces = len(str(largest)) # len et str conversion pour la reecriture 
                                   # permet la conversion en str


     for row in tableau:
        currRow = "|" # la fonction currRow permet de mettre des barriers
        for element in row:
            #Si l elemnt est = 0 il y a de la place 
            if element == 0:
                currRow += "" * numSpaces + "|"
                #SI non nous avons la valeur 
            else:
              currRow += (""* (numSpaces - len(str(element)))) + str(element) + "|" # pour avoir plus de place pour les plus de place grand element

        # Afficher la ligne generatrice 
        print(currRow)
     print()
# la partie vue precedement ne servira pas pour la fenetre tkinter car on as deja programme*
# notre tableau  
    
#display()
 # a savoir si on multiplie un string avec un nombre cela cree un nouveau string 
 # si on multiplie un espace par 4 le nouveau string sera de 4 espace 
 # pour un grand nombre on as besoin par exemple pour ces 1 chiffres de 2 espace 
 # pour cela on vas modifier le code a cett endroit currrow str


#b (pour info i=ligne , j= colonne)
# creation d une fonction pour faire bouger une ligne a gauche par exemple 
def transposeuneseulligne(row):
    # permetrre a tout les elements de bouger si possible vers la gauche but rechercher 
    for j in range (tailledutableau - 1):
      for i in range (tailledutableau -1,0,-1):
        # ici permettre au case vide d etre remplie du faite que elle se feront bouger vers les case libres
        if row[i-1] ==0 : # 
           row[i - 1] = row[i]
           row[i] = 0

    # permettre a toute les valeur de fusionner vers la gauche 
    for i in range(tailledutableau - 1):
        # test pour savoir si les deux valeurs sont identtique et pour le prochain 
        if row[i] == row[i+1]:
          row[i]*=2
          row[i + 1] = 0 

    # tous faire mettre vers la gauche encore une fois 
    for i in range(tailledutableau -1,0,-1):
        if row[i - 1]==0 :
           row[i - 1] = row[i]
           row[i]=0
    return row 

# cette fonction fusionne tous le tableau a gauche 
def transposegauche(actuelletableau):
    # fusionne tout les lignes a gauche du tableau 
    for i in range(tailledutableau):
        actuelletableau[i] = transposeuneseulligne(actuelletableau[i])

    return actuelletableau
    
# fonction pour les differentes direction 
def reverse(row):
    # tous les element dans la ligne son dans une liste et leur role sera inverser 
    new=[] # defini une nouvelle liste new
    for i in range(tailledutableau -1,-1,-1): # taille du tableau = 4 
        new.append(row[i]) # premettant d apparaitre le row 
    return new # retourner indefiniment la liste 

# fonction pour fusionner tout les element a droite 
def transposedroite(actuelletableau):
    #pour toute les ligne du tableau 
   for i in range(tailledutableau):
       # Renverse lles lignes transpose a gauche  et les reverse en arriere
       actuelletableau[i]= reverse(actuelletableau[i])
       actuelletableau[i]= transposeuneseulligne(actuelletableau[i])
       actuelletableau[i]= reverse(actuelletableau[i])
   return actuelletableau


# pour aller en haut
# la fonction transpose permet de retourner le tableau a travers une diagonale
# creation de la fonction transpose permettant la transpose dans tout le tableau 
# par exemple un element de la premiere ligne et de la deuxieme colonne,
#ira dans la deuxieme ligne de la premiere colonne
# creation de la fonction transpose 
# pas actuellement fini
def transpose(actuelletableau):
    for j in range(tailledutableau): # permmenant a des element de voir si il sont dans differente diagonale 
        for i in range(j,tailledutableau):
            if not i == j : # pour les partagers echanger les element de la diagonale
                bones = actuelletableau[j][i] # echanger les element 
                actuelletableau[j][i] = actuelletableau[i][j]
                actuelletableau[i][j] = bones # j ai choisi le bones par hasard pour definir
    return actuelletableau                    # actuelletableau[i][j]

# fonction permettant de transposer tout le tableau (on utilisera la fonction transpose gauche)
def transposetoutenhaut(actuelletableau):
    # transpose tout le tableau si il est gauche transpose en arriere 
    actuelletableau = transpose(actuelletableau)
    actuelletableau = transposegauche(actuelletableau)
    actuelletableau = transpose(actuelletableau)

    return actuelletableau

# fonction pour tout mettre en bas (on utilisera la fonction transpose droite)
def toutenbas(actuelletableau):
    actuelletableau= transpose(actuelletableau)
    actuelletableau= transposedroite(actuelletableau)
    actuelletableau= transpose(actuelletableau)

    return actuelletableau # permet de mettre a jour son tableau a chaque fois
                               



# c = choisir sois un 2 ou 4 sachant que il a 75% de chance d obtenir un 2 que un 4
def deux_quatre():
    if random.randint(1,8) == 1:# on peut chances les coordonne x et y pour avoir moins ou plus de chance
        return 4 # 1 chance sur 8 de nous retourner un 4
    else:
        return 2 # PLus de chance d obtenir un deux

#fonction detectant les cases vides 
def valuercasesvides():
    lignealeatoire = random.randint(0,tailledutableau-1)
    colonnelibre = random.randint(0,tailledutableau-1)

# trouver un endroit vides 
    while not tableau[lignealeatoire][colonnelibre] == 0:
       lignealeatoire = random.randint(0,tailledutableau-1)
       colonnelibre = random.randint(0,tailledutableau-1)

# trouver la case vide avec la nouvelle valeur 
    tableau[lignealeatoire][colonnelibre] = deux_quatre()

# creation de fonction fin_du_jeu(si la personne a gagner)
def gagner():
    for row in tableau:
        if 2048 in row: # apparation 2048 = fin de jeu 
           return True 
    return False

# savoir si la personne a perdu  fonction game over d ou elle ne peut pas bouger
def bougepas():
    # creation de 2 copy du tableau 
    tableaucopya= copy.deepcopy(tableau) # foncction deep copy est permet de copier son tableau 
    tableaucopyb= copy.deepcopy(tableau)
    # test de reconnaisance pour savoir si on peut bouger 
    tableaucopya = toutenbas(tableaucopya)
    if tableaucopya == tableaucopyb:
        tableaucopya = transposetoutenhaut(tableaucopya)
        if tableaucopya == tableaucopyb:
            tableaucopya = transposegauche(tableaucopya)
            if tableaucopya == tableaucopyb:
                tableaucopya = transposedroite(tableaucopya)
                if tableaucopya == tableaucopyb:
                    return True
    return False
# creation d un tableau vierge  ( sois le tableau du debut totalement vide )
tableau=[]
for i in range(tailledutableau):
    row=[]
    for j in range(tailledutableau):
        row.append(0) # tout le tableau au debut a 0 (on le rempliera avec la fonction suivante)
    tableau.append(row)

# 2 valeur apparaissant n importe ou dans le tableau 
deuxvaleurdudebut = 2 # le 2 ici signifie les 2 valeurs qui vont apparaitre dans le tableau au debut du jeu
while deuxvaleurdudebut >0:
    lignealeatoire= random.randint(0, tailledutableau - 1)# choisi dans le tableau une ligne aleatoire
    colonnelibre=random.randint(0,  tailledutableau - 1)# choisi dans le tableau une colonne aleatoire

    if tableau[lignealeatoire][colonnelibre] ==0: # si une ligne et colonne == 0
       tableau[lignealeatoire][colonnelibre] = deux_quatre() # appariton de 
       deuxvaleurdudebut -=1                                         # un 2 et un 2 ou un 2 et un 4
# permettant aussi l apparation au debut du jeu de 2 valeur a 2 differents endroit
print("Bonjour jeux 2048s")# utilison print pour les message plutot 
display()# Pour afficher le tableau mieux vos utiliser le display() car ce dernier permet 
         # de afficher plus rapidement et plus efficacement un tableau de valeur

# codage pour la determination du fin du jeu 

# arrete de faire (sois arrete le jeu l utilisateur ne peut plus jouer )
arrete2048= False 

while not arrete2048:
    direct = input("Quel direction choisissez vous Monsieur\Madame ?")
    # si il peut encore bouger 
    choisivaleur=True 
    # regardons si les mouvements se realise  copy du tableau 
    Hyutableau= copy.deepcopy(tableau) #gardant en mémoire dans un dictionnaire memo les objets déjà copiés durant la phase de copie actuelle 
                                       # permettant de savoir si le joueur a deja appuyer sur la meme touche
    # cette fois on vas bouger en haut a droite de gauche a droite 
    if direct =="d":
      tableau = transposedroite(tableau) # direction vers la droite
    elif direct =="z":
        tableau = transposetoutenhaut(tableau) # direction vers le haut 
    elif direct == "q":
        tableau = transposegauche(tableau) # direction vers la gauche
    elif direct == "s":
        tableau = toutenbas(tableau) #direction vers le bas
    else:
       choisivaleur=False  # cela veut dire que l utilisatuer ne peut choisir que 4 touche si il affiche 
                       # autre chose cela veut dire que cela ne s'écutera pas 

    # demander a l utilisateur de donner donner un autre touche si ca touche selectioner et pas correct
    if not choisivaleur:
        print("veuillez choisir un bon resultat s il vous plait ")
    # si sa touche choisi et correct
    else:
       # test si ca bouge 
       if tableau == Hyutableau:
           # leur dire d utiliser une autre fois la touche deja utiliser par exemple
           print("choisir Autre direction cardeja utiliser")
       else:
           # savoir si on as gagner 
           if gagner():
               display()
               print("Félicitation pour votre victoire")
               arrete2048=True # car le jeu ce termine apres la victoire
           else:
           # ajouter une nouvelle fonction 
             valuercasesvides()
           
             display()

           # determine pas de deplacemnt
           if bougepas():
               print("game over")









    


